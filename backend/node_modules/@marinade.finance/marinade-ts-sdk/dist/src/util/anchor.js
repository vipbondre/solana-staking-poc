"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEpochInfo = exports.getParsedStakeAccountInfo = exports.getOrCreateAssociatedTokenAccount = exports.getAssociatedTokenAccountAddress = exports.BNOrNull = exports.web3PubKeyOrNull = exports.U64_MAX = exports.STAKE_PROGRAM_ID = exports.SYSTEM_PROGRAM_ID = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const spl_token_3_x_1 = require("@solana/spl-token-3.x");
const web3_js_1 = require("@solana/web3.js");
exports.SYSTEM_PROGRAM_ID = anchor_1.web3.SystemProgram.programId;
exports.STAKE_PROGRAM_ID = anchor_1.web3.StakeProgram.programId;
exports.U64_MAX = new anchor_1.BN('ffffffffffffffff', 16);
function web3PubKeyOrNull(value) {
    return value === null ? null : new anchor_1.web3.PublicKey(value);
}
exports.web3PubKeyOrNull = web3PubKeyOrNull;
function BNOrNull(value) {
    return value === null ? null : new anchor_1.BN(value);
}
exports.BNOrNull = BNOrNull;
function getAssociatedTokenAccountAddress(mint, owner) {
    return __awaiter(this, void 0, void 0, function* () {
        return anchor_1.utils.token.associatedAddress({ mint, owner });
    });
}
exports.getAssociatedTokenAccountAddress = getAssociatedTokenAccountAddress;
function getOrCreateAssociatedTokenAccount(anchorProvider, mintAddress, ownerAddress, payerAddress) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const existingTokenAccounts = yield anchorProvider.connection.getTokenAccountsByOwner(ownerAddress, {
            mint: mintAddress,
        });
        const [existingTokenAccount] = existingTokenAccounts.value;
        const associatedTokenAccountAddress = (_a = existingTokenAccount === null || existingTokenAccount === void 0 ? void 0 : existingTokenAccount.pubkey) !== null && _a !== void 0 ? _a : (yield getAssociatedTokenAccountAddress(mintAddress, ownerAddress));
        let createAssociateTokenInstruction = null;
        try {
            yield (0, spl_token_3_x_1.getAccount)(anchorProvider.connection, associatedTokenAccountAddress);
        }
        catch (err) {
            if (!(err instanceof spl_token_3_x_1.TokenError) ||
                err.name !== 'TokenAccountNotFoundError') {
                throw err;
            }
            createAssociateTokenInstruction = (0, spl_token_3_x_1.createAssociatedTokenAccountInstruction)(payerAddress !== null && payerAddress !== void 0 ? payerAddress : ownerAddress, associatedTokenAccountAddress, ownerAddress, mintAddress);
        }
        return {
            associatedTokenAccountAddress,
            createAssociateTokenInstruction,
        };
    });
}
exports.getOrCreateAssociatedTokenAccount = getOrCreateAssociatedTokenAccount;
function getParsedStakeAccountInfo(providerOrConnection, stakeAccountAddress) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
    return __awaiter(this, void 0, void 0, function* () {
        const connection = providerOrConnection instanceof web3_js_1.Connection
            ? providerOrConnection
            : providerOrConnection.connection;
        const { value: stakeAccountInfo } = yield connection.getParsedAccountInfo(stakeAccountAddress);
        if (!stakeAccountInfo) {
            throw new Error(`Failed to find the stake account ${stakeAccountAddress.toBase58()}`);
        }
        if (!stakeAccountInfo.owner.equals(exports.STAKE_PROGRAM_ID)) {
            throw new Error(`${stakeAccountAddress.toBase58()} is not a stake account because owner is ${stakeAccountInfo.owner}`);
        }
        if (!stakeAccountInfo.data ||
            stakeAccountInfo.data instanceof Buffer ||
            !('parsed' in stakeAccountInfo.data)) {
            throw new Error('Failed to parse the stake account data');
        }
        const { parsed: parsedData } = stakeAccountInfo.data;
        const activationEpoch = BNOrNull((_d = (_c = (_b = (_a = parsedData === null || parsedData === void 0 ? void 0 : parsedData.info) === null || _a === void 0 ? void 0 : _a.stake) === null || _b === void 0 ? void 0 : _b.delegation) === null || _c === void 0 ? void 0 : _c.activationEpoch) !== null && _d !== void 0 ? _d : null);
        const deactivationEpoch = BNOrNull((_h = (_g = (_f = (_e = parsedData === null || parsedData === void 0 ? void 0 : parsedData.info) === null || _e === void 0 ? void 0 : _e.stake) === null || _f === void 0 ? void 0 : _f.delegation) === null || _g === void 0 ? void 0 : _g.deactivationEpoch) !== null && _h !== void 0 ? _h : null);
        const lockup = (_k = (_j = parsedData === null || parsedData === void 0 ? void 0 : parsedData.info) === null || _j === void 0 ? void 0 : _j.meta) === null || _k === void 0 ? void 0 : _k.lockup;
        const balanceLamports = BNOrNull(stakeAccountInfo.lamports);
        const stakedLamports = BNOrNull((_o = (_m = (_l = parsedData === null || parsedData === void 0 ? void 0 : parsedData.info) === null || _l === void 0 ? void 0 : _l.stake) === null || _m === void 0 ? void 0 : _m.delegation.stake) !== null && _o !== void 0 ? _o : null);
        const { epoch: currentEpoch } = yield connection.getEpochInfo();
        const currentUnixTimestamp = Date.now() / 1000;
        return {
            address: stakeAccountAddress,
            ownerAddress: stakeAccountInfo.owner,
            authorizedStakerAddress: web3PubKeyOrNull((_s = (_r = (_q = (_p = parsedData === null || parsedData === void 0 ? void 0 : parsedData.info) === null || _p === void 0 ? void 0 : _p.meta) === null || _q === void 0 ? void 0 : _q.authorized) === null || _r === void 0 ? void 0 : _r.staker) !== null && _s !== void 0 ? _s : null),
            authorizedWithdrawerAddress: web3PubKeyOrNull((_w = (_v = (_u = (_t = parsedData === null || parsedData === void 0 ? void 0 : parsedData.info) === null || _t === void 0 ? void 0 : _t.meta) === null || _u === void 0 ? void 0 : _u.authorized) === null || _v === void 0 ? void 0 : _v.withdrawer) !== null && _w !== void 0 ? _w : null),
            voterAddress: web3PubKeyOrNull((_0 = (_z = (_y = (_x = parsedData === null || parsedData === void 0 ? void 0 : parsedData.info) === null || _x === void 0 ? void 0 : _x.stake) === null || _y === void 0 ? void 0 : _y.delegation) === null || _z === void 0 ? void 0 : _z.voter) !== null && _0 !== void 0 ? _0 : null),
            activationEpoch,
            deactivationEpoch,
            isCoolingDown: deactivationEpoch ? !deactivationEpoch.eq(exports.U64_MAX) : false,
            isLockedUp: (lockup === null || lockup === void 0 ? void 0 : lockup.custodian) &&
                (lockup === null || lockup === void 0 ? void 0 : lockup.custodian) !== '' &&
                ((lockup === null || lockup === void 0 ? void 0 : lockup.epoch) > currentEpoch ||
                    (lockup === null || lockup === void 0 ? void 0 : lockup.unixTimestamp) > currentUnixTimestamp),
            balanceLamports,
            stakedLamports,
        };
    });
}
exports.getParsedStakeAccountInfo = getParsedStakeAccountInfo;
function getEpochInfo(connection) {
    return __awaiter(this, void 0, void 0, function* () {
        const epochInfo = yield connection.getEpochInfo();
        const samples = yield connection.getRecentPerformanceSamples(64);
        const sampleSlots = samples.reduce((slots, sample) => sample.numSlots + slots, 0);
        const sampleSeconds = samples.reduce((seconds, sample) => sample.samplePeriodSecs + seconds, 0);
        const avgSlotDuration = (sampleSeconds / sampleSlots) * 1000;
        const slotsRemainingInEpoch = epochInfo.slotsInEpoch - epochInfo.slotIndex;
        const msUntilEpochEnd = avgSlotDuration * slotsRemainingInEpoch;
        const msElapsed = epochInfo.slotIndex * avgSlotDuration;
        const epochProgress = (100 * epochInfo.slotIndex) / epochInfo.slotsInEpoch;
        return Object.assign(Object.assign({}, epochInfo), { msUntilEpochEnd,
            msElapsed,
            epochProgress,
            avgSlotDuration,
            slotsRemainingInEpoch });
    });
}
exports.getEpochInfo = getEpochInfo;
//# sourceMappingURL=anchor.js.map