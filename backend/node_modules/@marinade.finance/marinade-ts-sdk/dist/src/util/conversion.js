"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcLamportsWithdrawAmount = exports.divideBnToNumber = exports.solToLamports = exports.lamportsToSol = exports.tokenBalanceToNumber = exports.withDecimalPoint = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const SOL_DECIMALS = 9;
function withDecimalPoint(bn, decimals) {
    const s = bn.toString().padStart(decimals + 1, '0');
    const l = s.length;
    return s.slice(0, l - decimals) + '.' + s.slice(-decimals);
}
exports.withDecimalPoint = withDecimalPoint;
function tokenBalanceToNumber(bn, decimals) {
    return Number(withDecimalPoint(bn, decimals));
}
exports.tokenBalanceToNumber = tokenBalanceToNumber;
function lamportsToSol(bn) {
    return tokenBalanceToNumber(bn, SOL_DECIMALS);
}
exports.lamportsToSol = lamportsToSol;
function solToLamports(amountSol) {
    return new anchor_1.BN(amountSol.toFixed(SOL_DECIMALS).replace('.', ''));
}
exports.solToLamports = solToLamports;
function divideBnToNumber(numerator, denominator) {
    if (denominator.isZero()) {
        return 0;
    }
    const quotient = numerator.div(denominator);
    const rem = numerator.umod(denominator);
    const gcd = rem.gcd(denominator);
    const quotientNumber = parseFloat(quotient.toString());
    const remNumber = parseFloat(rem.div(gcd).toString());
    const denominatorNumber = parseFloat(denominator.div(gcd).toString());
    return quotientNumber + remNumber / denominatorNumber;
}
exports.divideBnToNumber = divideBnToNumber;
function calcLamportsWithdrawAmount(stakePool, poolTokens) {
    const numerator = poolTokens.mul(stakePool.totalLamports);
    const denominator = stakePool.poolTokenSupply;
    if (numerator.lt(denominator)) {
        return 0;
    }
    return divideBnToNumber(numerator, denominator);
}
exports.calcLamportsWithdrawAmount = calcLamportsWithdrawAmount;
//# sourceMappingURL=conversion.js.map