"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Marinade = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const marinade_config_1 = require("./config/marinade-config");
const anchor_1 = require("@coral-xyz/anchor");
const marinade_state_1 = require("./marinade-state/marinade-state");
const anchor_2 = require("./util/anchor");
const marinade_finance_program_1 = require("./programs/marinade-finance-program");
const marinade_referral_program_1 = require("./programs/marinade-referral-program");
const marinade_referral_partner_state_1 = require("./marinade-referral-state/marinade-referral-partner-state");
const marinade_referral_global_state_1 = require("./marinade-referral-state/marinade-referral-global-state");
const assert_1 = require("./util/assert");
const ticket_account_1 = require("./marinade-state/borsh/ticket-account");
const util_1 = require("./util");
const directed_stake_sdk_1 = require("@marinade.finance/directed-stake-sdk");
const nodewallet_1 = __importDefault(require("@coral-xyz/anchor/dist/cjs/nodewallet"));
const spl_stake_pool_1 = require("@solana/spl-stake-pool");
const stake_pool_helpers_1 = require("./util/stake-pool-helpers");
const web3_js_1 = require("@solana/web3.js");
class Marinade {
    constructor(config = new marinade_config_1.MarinadeConfig()) {
        var _a;
        this.config = config;
        this.provider = new anchor_1.AnchorProvider(this.config.connection, new nodewallet_1.default(anchor_1.web3.Keypair.generate()), { commitment: 'confirmed' });
        this.directedStakeSdk = new directed_stake_sdk_1.DirectedStakeSdk({
            connection: this.config.connection,
            wallet: {
                signTransaction: () => __awaiter(this, void 0, void 0, function* () { return new Promise(() => new anchor_1.web3.Transaction()); }),
                signAllTransactions: () => __awaiter(this, void 0, void 0, function* () { return new Promise(() => [new anchor_1.web3.Transaction()]); }),
                publicKey: (_a = this.config.publicKey) !== null && _a !== void 0 ? _a : anchor_1.web3.PublicKey.default,
            },
        });
        /**
         * The main Marinade Program
         */
        this.marinadeFinanceProgram = new marinade_finance_program_1.MarinadeFinanceProgram(this.config.marinadeFinanceProgramId, this.provider);
        /**
         * The Marinade Program for referral partners
         */
        this.marinadeReferralProgram = new marinade_referral_program_1.MarinadeReferralProgram(this.config.marinadeReferralProgramId, this.provider, this.config.referralCode, this);
    }
    isReferralProgram() {
        return this.config.referralCode !== null;
    }
    provideReferralOrMainProgram() {
        return this.isReferralProgram()
            ? this.marinadeReferralProgram
            : this.marinadeFinanceProgram;
    }
    /**
     * Fetch the Marinade's internal state
     */
    getMarinadeState() {
        return __awaiter(this, void 0, void 0, function* () {
            return marinade_state_1.MarinadeState.fetch(this);
        });
    }
    /**
     * Fetch the Marinade referral partner's state
     */
    getReferralPartnerState(referralCode) {
        return __awaiter(this, void 0, void 0, function* () {
            return marinade_referral_partner_state_1.MarinadeReferralPartnerState.fetch(this, referralCode);
        });
    }
    /**
     * Fetch the Marinade referral program's global state
     */
    getReferralGlobalState() {
        return __awaiter(this, void 0, void 0, function* () {
            return marinade_referral_global_state_1.MarinadeReferralGlobalState.fetch(this);
        });
    }
    /**
     * Fetch all the referral partners
     */
    getReferralPartners() {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield this.config.connection.getProgramAccounts(new anchor_1.web3.PublicKey(this.config.marinadeReferralProgramId), {
                filters: [
                    {
                        dataSize: this.marinadeReferralProgram.program.account.referralState.size +
                            20 +
                            96, // number of bytes,
                    },
                ],
            });
            const codes = accounts.map(acc => acc.pubkey);
            return yield Promise.all(codes.map(referralCode => this.getReferralPartnerState(referralCode)));
        });
    }
    /**
     * Fetches the voteRecord of a given user
     *
     * @param {web3.PublicKey} userPublicKey - The PublicKey of the user
     */
    getUsersVoteRecord(userPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = (0, directed_stake_sdk_1.voteRecordAddress)({
                root: new anchor_1.web3.PublicKey(directed_stake_sdk_1.DEFAULT_DIRECTED_STAKE_ROOT),
                owner: userPublicKey,
            }).address;
            const voteRecords = yield (0, directed_stake_sdk_1.findVoteRecords)({
                sdk: this.directedStakeSdk,
                owner: userPublicKey,
            });
            return {
                voteRecord: voteRecords.length === 1 ? voteRecords[0] : undefined,
                address,
            };
        });
    }
    /**
     * Returns a transaction with the instructions to
     * Add liquidity to the liquidity pool and receive LP tokens
     *
     * @param {BN} amountLamports - The amount of lamports added to the liquidity pool
     */
    addLiquidity(amountLamports) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const marinadeState = yield this.getMarinadeState();
            const transaction = new anchor_1.web3.Transaction();
            const { associatedTokenAccountAddress: associatedLPTokenAccountAddress, createAssociateTokenInstruction, } = yield (0, anchor_2.getOrCreateAssociatedTokenAccount)(this.provider, marinadeState.lpMintAddress, ownerAddress);
            if (createAssociateTokenInstruction) {
                transaction.add(createAssociateTokenInstruction);
            }
            const addLiquidityInstruction = yield this.marinadeFinanceProgram.addLiquidityInstructionBuilder({
                marinadeState,
                associatedLPTokenAccountAddress,
                ownerAddress,
                amountLamports,
            });
            transaction.add(addLiquidityInstruction);
            return {
                associatedLPTokenAccountAddress,
                transaction,
            };
        });
    }
    /**
     * Returns a transaction with the instructions to
     * Burn LP tokens and get SOL and mSOL back from the liquidity pool
     *
     * @param {BN} amountLamports - The amount of LP tokens burned
     */
    removeLiquidity(amountLamports) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const marinadeState = yield this.getMarinadeState();
            const transaction = new anchor_1.web3.Transaction();
            const associatedLPTokenAccountAddress = yield (0, anchor_2.getAssociatedTokenAccountAddress)(marinadeState.lpMintAddress, ownerAddress);
            const { associatedTokenAccountAddress: associatedMSolTokenAccountAddress, createAssociateTokenInstruction, } = yield (0, anchor_2.getOrCreateAssociatedTokenAccount)(this.provider, marinadeState.mSolMintAddress, ownerAddress);
            if (createAssociateTokenInstruction) {
                transaction.add(createAssociateTokenInstruction);
            }
            const removeLiquidityInstruction = yield this.marinadeFinanceProgram.removeLiquidityInstructionBuilder({
                amountLamports,
                marinadeState,
                ownerAddress,
                associatedLPTokenAccountAddress,
                associatedMSolTokenAccountAddress,
            });
            transaction.add(removeLiquidityInstruction);
            return {
                associatedLPTokenAccountAddress,
                associatedMSolTokenAccountAddress,
                transaction,
            };
        });
    }
    /**
     * Creates necessary directed stake voting instructions for the specified validator.
     * If the vote address is left undefined the standard delegation strategy is used.
     *
     * @param {web3.PublicKey} validatorVoteAddress - The vote address to identify the validator
     */
    createDirectedStakeVoteIx(validatorVoteAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const owner = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const { voteRecord } = yield this.getUsersVoteRecord(owner);
            if (!voteRecord) {
                if (validatorVoteAddress) {
                    return (yield (0, directed_stake_sdk_1.withCreateVote)({
                        sdk: this.directedStakeSdk,
                        target: validatorVoteAddress,
                    })).instruction;
                }
                return;
            }
            if (validatorVoteAddress) {
                return (yield (0, directed_stake_sdk_1.withUpdateVote)({
                    sdk: this.directedStakeSdk,
                    target: validatorVoteAddress,
                    voteRecord: voteRecord.publicKey,
                })).instruction;
            }
            return (yield (0, directed_stake_sdk_1.withRemoveVote)({
                sdk: this.directedStakeSdk,
                voteRecord: voteRecord.publicKey,
            })).instruction;
        });
    }
    /**
     * Returns a transaction with the instructions to
     * Stake SOL in exchange for mSOL
     *
     * @param {BN} amountLamports - The amount lamports staked
     * @param {DepositOptions} options - Additional deposit options
     */
    deposit(amountLamports, options = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const feePayer = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const mintToOwnerAddress = (0, assert_1.assertNotNullAndReturn)((_a = options.mintToOwnerAddress) !== null && _a !== void 0 ? _a : this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const marinadeState = yield this.getMarinadeState();
            const transaction = new anchor_1.web3.Transaction();
            const { associatedTokenAccountAddress: associatedMSolTokenAccountAddress, createAssociateTokenInstruction, } = yield (0, anchor_2.getOrCreateAssociatedTokenAccount)(this.provider, marinadeState.mSolMintAddress, mintToOwnerAddress, feePayer);
            if (createAssociateTokenInstruction) {
                transaction.add(createAssociateTokenInstruction);
            }
            const program = this.provideReferralOrMainProgram();
            const depositInstruction = yield program.depositInstructionBuilder({
                amountLamports,
                marinadeState,
                transferFrom: feePayer,
                associatedMSolTokenAccountAddress,
            });
            transaction.add(depositInstruction);
            return {
                associatedMSolTokenAccountAddress,
                transaction,
            };
        });
    }
    /**
     *  * ⚠️ WARNING ⚠️ The liquidity in the pool for this swap is typically low,
     * which can result in high transaction fees. It is advisable to consider
     * Jup swap API or proceed with caution.
     *
     * Returns a transaction with the instructions to
     * Swap your mSOL to get back SOL immediately using the liquidity pool
     *
     * @param {BN} amountLamports - The amount of mSOL exchanged for SOL
     */
    liquidUnstake(amountLamports, associatedMSolTokenAccountAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const marinadeState = yield this.getMarinadeState();
            const transaction = new anchor_1.web3.Transaction();
            if (!associatedMSolTokenAccountAddress) {
                const associatedTokenAccountInfos = yield (0, anchor_2.getOrCreateAssociatedTokenAccount)(this.provider, marinadeState.mSolMintAddress, ownerAddress);
                const createAssociateTokenInstruction = associatedTokenAccountInfos.createAssociateTokenInstruction;
                associatedMSolTokenAccountAddress =
                    associatedTokenAccountInfos.associatedTokenAccountAddress;
                if (createAssociateTokenInstruction) {
                    transaction.add(createAssociateTokenInstruction);
                }
            }
            const program = this.provideReferralOrMainProgram();
            const liquidUnstakeInstruction = yield program.liquidUnstakeInstructionBuilder({
                amountLamports,
                marinadeState,
                ownerAddress,
                associatedMSolTokenAccountAddress,
            });
            transaction.add(liquidUnstakeInstruction);
            return {
                associatedMSolTokenAccountAddress,
                transaction,
            };
        });
    }
    /**
     * Returns a transaction with the instructions to
     * Deposit a delegated stake account.
     * Note that the stake must be fully activated and the validator must be known to Marinade
     *
     * @param {web3.PublicKey} stakeAccountAddress - The account to be deposited
     */
    depositStakeAccount(stakeAccountAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const stakeAccountInfo = yield (0, anchor_2.getParsedStakeAccountInfo)(this.provider, stakeAccountAddress);
            const marinadeState = yield this.getMarinadeState();
            const rent = yield this.provider.connection.getMinimumBalanceForRentExemption(anchor_1.web3.StakeProgram.space);
            return this.depositStakeAccountByAccount(stakeAccountInfo, rent, marinadeState);
        });
    }
    /**
     * @beta
     *
     * Returns a transaction with the instructions to
     * Deposit a deactivating stake account.
     * Note that the stake must be deactivating and the validator must be known to Marinade
     *
     * @param {web3.PublicKey} stakeAccountAddress - The account to be deposited
     */
    depositDeactivatingStakeAccount(stakeAccountAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const stakeAccountInfo = yield (0, anchor_2.getParsedStakeAccountInfo)(this.provider, stakeAccountAddress);
            if (!stakeAccountInfo.voterAddress) {
                throw new Error("Stake account's votes could not be fetched/parsed.");
            }
            const marinadeState = yield this.getMarinadeState();
            const delegateTransaction = web3_js_1.StakeProgram.delegate({
                stakePubkey: stakeAccountAddress,
                authorizedPubkey: ownerAddress,
                votePubkey: stakeAccountInfo.voterAddress,
            });
            const { associatedTokenAccountAddress: associatedMSolTokenAccountAddress, createAssociateTokenInstruction, } = yield (0, anchor_2.getOrCreateAssociatedTokenAccount)(this.provider, marinadeState.mSolMintAddress, ownerAddress);
            if (createAssociateTokenInstruction) {
                delegateTransaction.instructions.push(createAssociateTokenInstruction);
            }
            const duplicationFlag = yield marinadeState.validatorDuplicationFlag(stakeAccountInfo.voterAddress);
            const { validatorRecords } = yield marinadeState.getValidatorRecords();
            const validatorLookupIndex = validatorRecords.findIndex(({ validatorAccount }) => validatorAccount.equals(stakeAccountInfo.voterAddress));
            const validatorIndex = validatorLookupIndex === -1
                ? marinadeState.state.validatorSystem.validatorList.count
                : validatorLookupIndex;
            const depositInstruction = yield this.provideReferralOrMainProgram().depositStakeAccountInstructionBuilder({
                validatorIndex,
                marinadeState,
                duplicationFlag,
                ownerAddress,
                stakeAccountAddress,
                authorizedWithdrawerAddress: ownerAddress,
                associatedMSolTokenAccountAddress,
            });
            delegateTransaction.instructions.push(depositInstruction);
            return {
                transaction: delegateTransaction,
                associatedMSolTokenAccountAddress,
            };
        });
    }
    /**
     * Returns a transaction with the instructions to
     * Deposit a delegated stake account.
     * Note that the stake must be fully activated and the validator must be known to Marinade
     *
     * @param {ParsedStakeAccountInfo} stakeAccountInfo - Parsed Stake Account info
     * @param {number} rent - Rent needed for a stake account
     * @param {MarinadeState} marinadeState - Marinade State needed for retrieving validator info
     */
    depositStakeAccountByAccount(stakeAccountInfo, rent, marinadeState) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const transaction = new anchor_1.web3.Transaction();
            const currentEpoch = yield this.provider.connection.getEpochInfo();
            const { authorizedWithdrawerAddress, voterAddress, activationEpoch, isCoolingDown, isLockedUp, stakedLamports, balanceLamports, } = stakeAccountInfo;
            if (!authorizedWithdrawerAddress) {
                throw new Error('Withdrawer address is not available!');
            }
            if (isLockedUp) {
                throw new Error('The stake account is locked up!');
            }
            if (!activationEpoch || !voterAddress) {
                throw new Error('The stake account is not delegated!');
            }
            if (isCoolingDown) {
                transaction.add(anchor_1.web3.StakeProgram.delegate({
                    stakePubkey: stakeAccountInfo.address,
                    authorizedPubkey: ownerAddress,
                    votePubkey: voterAddress,
                }));
            }
            if (stakedLamports && (balanceLamports === null || balanceLamports === void 0 ? void 0 : balanceLamports.gt(stakedLamports))) {
                const lamportsToWithdraw = balanceLamports.sub(stakedLamports).toNumber() - rent;
                if (lamportsToWithdraw > 0)
                    transaction.add(anchor_1.web3.StakeProgram.withdraw({
                        stakePubkey: stakeAccountInfo.address,
                        authorizedPubkey: ownerAddress,
                        toPubkey: ownerAddress,
                        lamports: lamportsToWithdraw,
                    }));
            }
            const waitEpochs = 2;
            const earliestDepositEpoch = activationEpoch.addn(waitEpochs);
            if (earliestDepositEpoch.gtn(currentEpoch.epoch)) {
                throw new Error(`Deposited stake ${stakeAccountInfo.address} is not activated yet. Wait for #${earliestDepositEpoch} epoch`);
            }
            const { validatorRecords } = yield marinadeState.getValidatorRecords();
            const validatorLookupIndex = validatorRecords.findIndex(({ validatorAccount }) => validatorAccount.equals(voterAddress));
            const validatorIndex = validatorLookupIndex === -1
                ? marinadeState.state.validatorSystem.validatorList.count
                : validatorLookupIndex;
            const duplicationFlag = yield marinadeState.validatorDuplicationFlag(voterAddress);
            const { associatedTokenAccountAddress: associatedMSolTokenAccountAddress, createAssociateTokenInstruction, } = yield (0, anchor_2.getOrCreateAssociatedTokenAccount)(this.provider, marinadeState.mSolMintAddress, ownerAddress);
            if (createAssociateTokenInstruction) {
                transaction.add(createAssociateTokenInstruction);
            }
            const program = this.provideReferralOrMainProgram();
            const depositStakeAccountInstruction = yield program.depositStakeAccountInstructionBuilder({
                validatorIndex,
                marinadeState,
                duplicationFlag,
                authorizedWithdrawerAddress,
                associatedMSolTokenAccountAddress,
                ownerAddress,
                stakeAccountAddress: stakeAccountInfo.address,
            });
            transaction.add(depositStakeAccountInstruction);
            return {
                associatedMSolTokenAccountAddress,
                voterAddress,
                transaction,
                mintRatio: marinadeState.mSolPrice,
            };
        });
    }
    /**
     * @beta
     *
     * Generates a transaction to partially convert a fully activated delegated stake account into mSOL,
     * while the remaining balance continues to be staked in its native form.
     *
     * Requirements:
     * - The stake's validator should be recognized by Marinade.
     * - The transaction should be executed immediately after being generated.
     * - A minimum amount of 1 SOL is required for conversion to mSOL.
     *
     * @param {web3.PublicKey} stakeAccountAddress - The account to be deposited
     * @param {BN} solToKeep - Amount of SOL lamports to keep
     */
    partiallyDepositStakeAccount(stakeAccountAddress, solToKeep) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const stakeAccountInfo = yield (0, anchor_2.getParsedStakeAccountInfo)(this.provider, stakeAccountAddress);
            if (stakeAccountInfo.balanceLamports &&
                ((_a = stakeAccountInfo.balanceLamports) === null || _a === void 0 ? void 0 : _a.sub(solToKeep).toNumber()) < 1) {
                throw new Error("Can't deposit less than 1 SOL");
            }
            const rent = yield this.provider.connection.getMinimumBalanceForRentExemption(anchor_1.web3.StakeProgram.space);
            const marinadeState = yield this.getMarinadeState();
            const newStakeAccountKeypair = web3_js_1.Keypair.generate();
            const splitStakeTx = web3_js_1.StakeProgram.split({
                stakePubkey: stakeAccountAddress,
                authorizedPubkey: ownerAddress,
                splitStakePubkey: newStakeAccountKeypair.publicKey,
                lamports: solToKeep.toNumber(),
            }, rent);
            const { transaction: depositTx, associatedMSolTokenAccountAddress, voterAddress, } = yield this.depositStakeAccountByAccount(stakeAccountInfo, rent, marinadeState);
            splitStakeTx.instructions.push(...depositTx.instructions);
            return {
                transaction: splitStakeTx,
                associatedMSolTokenAccountAddress,
                stakeAccountKeypair: newStakeAccountKeypair,
                voterAddress,
            };
        });
    }
    /**
     * @beta
     *
     * Generates a transaction to convert an activating stake account into mSOL,
     * while the remaining balance continues to be staked in its native form.
     *
     * Requirements:
     * - The stake's validator should be recognized by Marinade.
     * - The transaction should be executed immediately after being generated.
     *
     * @param {web3.PublicKey} stakeAccountAddress - The account to be deposited
     * @param {BN} solToKeep - Amount of SOL lamports to keep as a stake account
     */
    depositActivatingStakeAccount(stakeAccountAddress, solToKeep) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const stakeAccountInfo = yield (0, anchor_2.getParsedStakeAccountInfo)(this.provider, stakeAccountAddress);
            if (!stakeAccountInfo.stakedLamports) {
                throw new Error(`Stake account ${stakeAccountInfo.address} does not have staked lamports`);
            }
            const rent = yield this.provider.connection.getMinimumBalanceForRentExemption(anchor_1.web3.StakeProgram.space);
            const lamportsToWithdraw = stakeAccountInfo.stakedLamports
                .sub(solToKeep)
                .add(new anchor_1.BN(rent));
            const newStakeAccountKeypair = web3_js_1.Keypair.generate();
            const transaction = new web3_js_1.Transaction();
            if (solToKeep.gt(new anchor_1.BN(0))) {
                const splitStakeTx = web3_js_1.StakeProgram.split({
                    stakePubkey: stakeAccountAddress,
                    authorizedPubkey: ownerAddress,
                    splitStakePubkey: newStakeAccountKeypair.publicKey,
                    lamports: solToKeep.toNumber(),
                }, rent);
                transaction.add(...splitStakeTx.instructions);
            }
            const deactivateTx = web3_js_1.StakeProgram.deactivate({
                stakePubkey: stakeAccountAddress,
                authorizedPubkey: ownerAddress,
            });
            transaction.add(...deactivateTx.instructions);
            const withdrawTx = web3_js_1.StakeProgram.withdraw({
                stakePubkey: stakeAccountAddress,
                authorizedPubkey: ownerAddress,
                toPubkey: ownerAddress,
                lamports: lamportsToWithdraw.toNumber(),
            });
            transaction.add(...withdrawTx.instructions);
            const { transaction: depositTx, associatedMSolTokenAccountAddress } = yield this.deposit(lamportsToWithdraw);
            transaction.instructions.push(...depositTx.instructions);
            return {
                transaction,
                associatedMSolTokenAccountAddress,
                stakeAccountKeypair: solToKeep.gt(new anchor_1.BN(0))
                    ? newStakeAccountKeypair
                    : undefined,
            };
        });
    }
    /**
     * Returns a transaction with the instructions to
     * Liquidate a delegated stake account.
     * Note that the stake must be fully activated and the validator must be known to Marinade
     * and that the transaction should be executed immediately after creation.
     *
     * @param {web3.PublicKey} stakeAccountAddress - The account to be deposited
     * @param {BN} mSolToKeep - Optional amount of mSOL lamports to keep
     */
    liquidateStakeAccount(stakeAccountAddress, mSolToKeep) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const stakeAccountInfo = yield (0, anchor_2.getParsedStakeAccountInfo)(this.provider, stakeAccountAddress);
            const rent = yield this.provider.connection.getMinimumBalanceForRentExemption(anchor_1.web3.StakeProgram.space);
            const marinadeState = yield this.getMarinadeState();
            const { transaction: depositTx, associatedMSolTokenAccountAddress, voterAddress, } = yield this.depositStakeAccountByAccount(stakeAccountInfo, rent, marinadeState);
            let mSolAmountToReceive = (0, util_1.computeMsolAmount)((_a = stakeAccountInfo.stakedLamports) !== null && _a !== void 0 ? _a : new anchor_1.BN(0), marinadeState);
            // when working with referral partner the costs of the deposit operation is subtracted from the mSOL amount the user receives
            if (this.isReferralProgram()) {
                const partnerOperationFee = (yield this.marinadeReferralProgram.getReferralStateData()).operationDepositStakeAccountFee;
                mSolAmountToReceive = mSolAmountToReceive.sub((0, util_1.proportionalBN)(mSolAmountToReceive, new anchor_1.BN(partnerOperationFee), new anchor_1.BN(10000)));
            }
            const unstakeAmountMSol = mSolAmountToReceive.sub(mSolToKeep !== null && mSolToKeep !== void 0 ? mSolToKeep : new anchor_1.BN(0));
            const { transaction: unstakeTx } = yield this.liquidUnstake(unstakeAmountMSol, associatedMSolTokenAccountAddress);
            return {
                transaction: depositTx.add(unstakeTx),
                associatedMSolTokenAccountAddress,
                voterAddress,
            };
        });
    }
    /**
     * @beta
     *
     * Returns a transaction with the instructions to
     * Partially liquidate a delegated stake account, while the rest remains staked natively.
     * Note that the stake must be fully activated and the validator must be known to Marinade
     * and that the transaction should be executed immediately after creation.
     *
     * @param {web3.PublicKey} stakeAccountAddress - The account to be deposited
     * @param {BN} solToKeep - Amount of SOL lamports to keep
     */
    partiallyLiquidateStakeAccount(stakeAccountAddress, solToKeep) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const stakeAccountInfo = yield (0, anchor_2.getParsedStakeAccountInfo)(this.provider, stakeAccountAddress);
            const rent = yield this.provider.connection.getMinimumBalanceForRentExemption(anchor_1.web3.StakeProgram.space);
            const stakeToLiquidate = (_a = stakeAccountInfo.stakedLamports) === null || _a === void 0 ? void 0 : _a.sub(solToKeep);
            if (!stakeToLiquidate || stakeToLiquidate.toNumber() < 1) {
                throw new Error("Can't liquidate less than 1 SOL");
            }
            const marinadeState = yield this.getMarinadeState();
            const newStakeAccountKeypair = web3_js_1.Keypair.generate();
            const splitStakeInstruction = web3_js_1.StakeProgram.split({
                stakePubkey: stakeAccountAddress,
                authorizedPubkey: ownerAddress,
                splitStakePubkey: newStakeAccountKeypair.publicKey,
                lamports: solToKeep.toNumber(),
            }, rent);
            const { transaction: depositTx, associatedMSolTokenAccountAddress, voterAddress, } = yield this.depositStakeAccountByAccount(stakeAccountInfo, rent, marinadeState);
            depositTx.instructions.unshift(...splitStakeInstruction.instructions);
            let mSolAmountToReceive = (0, util_1.computeMsolAmount)(stakeToLiquidate, marinadeState);
            // when working with referral partner the costs of the deposit operation is subtracted from the mSOL amount the user receives
            if (this.isReferralProgram()) {
                const partnerOperationFee = (yield this.marinadeReferralProgram.getReferralStateData()).operationDepositStakeAccountFee;
                mSolAmountToReceive = mSolAmountToReceive.sub((0, util_1.proportionalBN)(mSolAmountToReceive, new anchor_1.BN(partnerOperationFee), new anchor_1.BN(10000)));
            }
            const { transaction: unstakeTx } = yield this.liquidUnstake(mSolAmountToReceive, associatedMSolTokenAccountAddress);
            return {
                transaction: depositTx.add(unstakeTx),
                associatedMSolTokenAccountAddress,
                stakeAccountKeypair: newStakeAccountKeypair,
                voterAddress,
            };
        });
    }
    /**
     * Retrieve user's ticket accounts
     *
     * @param {web3.PublicKey} beneficiary - The owner of the ticket accounts
     */
    getDelayedUnstakeTickets(beneficiary) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.marinadeFinanceProgram.getDelayedUnstakeTickets(beneficiary);
        });
    }
    /**
     * Returns estimated Due date for an unstake ticket created now
     *
     */
    getEstimatedUnstakeTicketDueDate() {
        return __awaiter(this, void 0, void 0, function* () {
            const marinadeState = yield this.getMarinadeState();
            return this.marinadeFinanceProgram.getEstimatedUnstakeTicketDueDate(marinadeState);
        });
    }
    /**
     * Returns a transaction with the instructions to
     * Order Unstake to create a ticket which can be claimed later (with {@link claim}).
     *
     * @param {BN} msolAmount - The amount of mSOL in lamports to order for unstaking
     */
    orderUnstake(msolAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const marinadeState = yield this.getMarinadeState();
            const associatedMSolTokenAccountAddress = yield (0, anchor_2.getAssociatedTokenAccountAddress)(marinadeState.mSolMintAddress, ownerAddress);
            const ticketAccountKeypair = anchor_1.web3.Keypair.generate();
            const rent = yield this.provider.connection.getMinimumBalanceForRentExemption(ticket_account_1.TICKET_ACCOUNT_SIZE);
            const createAccountInstruction = anchor_1.web3.SystemProgram.createAccount({
                fromPubkey: ownerAddress,
                newAccountPubkey: ticketAccountKeypair.publicKey,
                lamports: rent,
                space: ticket_account_1.TICKET_ACCOUNT_SIZE,
                programId: this.marinadeFinanceProgram.programAddress,
            });
            const program = this.marinadeFinanceProgram;
            const orderUnstakeInstruction = yield program.orderUnstakeInstructionBuilder({
                msolAmount,
                marinadeState,
                ownerAddress,
                associatedMSolTokenAccountAddress,
                newTicketAccount: ticketAccountKeypair.publicKey,
            });
            const transaction = new anchor_1.web3.Transaction().add(createAccountInstruction, orderUnstakeInstruction);
            return {
                ticketAccountKeypair,
                transaction,
                associatedMSolTokenAccountAddress,
            };
        });
    }
    /**
     * Returns a transaction with the instructions to
     * Order Unstake to create a ticket which can be claimed later (with {@link claim}).
     *
     * @param {BN} msolAmount - The amount of mSOL in lamports to order for unstaking
     * @param {PublicKey} ticketAccountPublicKey - The public key of the ticket account that will sign the transaction
     */
    orderUnstakeWithPublicKey(msolAmount, ticketAccountPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const marinadeState = yield this.getMarinadeState();
            const associatedMSolTokenAccountAddress = yield (0, anchor_2.getAssociatedTokenAccountAddress)(marinadeState.mSolMintAddress, ownerAddress);
            const rent = yield this.provider.connection.getMinimumBalanceForRentExemption(ticket_account_1.TICKET_ACCOUNT_SIZE);
            const createAccountInstruction = anchor_1.web3.SystemProgram.createAccount({
                fromPubkey: ownerAddress,
                newAccountPubkey: ticketAccountPublicKey,
                lamports: rent,
                space: ticket_account_1.TICKET_ACCOUNT_SIZE,
                programId: this.marinadeFinanceProgram.programAddress,
            });
            const program = this.marinadeFinanceProgram;
            const orderUnstakeInstruction = yield program.orderUnstakeInstructionBuilder({
                msolAmount,
                marinadeState,
                ownerAddress,
                associatedMSolTokenAccountAddress,
                newTicketAccount: ticketAccountPublicKey,
            });
            const transaction = new anchor_1.web3.Transaction().add(createAccountInstruction, orderUnstakeInstruction);
            return {
                transaction,
                associatedMSolTokenAccountAddress,
            };
        });
    }
    /**
     * Returns a transaction with the instructions to
     * claim a ticket (created by {@link orderUnstake} beforehand).
     * Claimed SOLs will be sent to {@link MarinadeConfig.publicKey}.
     *
     * @param {web3.PublicKey} ticketAccount - Address of the ticket account for SOLs being claimed from
     */
    claim(ticketAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const marinadeState = yield this.getMarinadeState();
            const program = this.marinadeFinanceProgram;
            const claimInstruction = yield program.claimInstructionBuilder({
                marinadeState,
                ticketAccount,
                transferSolTo: ownerAddress,
            });
            const transaction = new anchor_1.web3.Transaction().add(claimInstruction);
            return {
                transaction,
            };
        });
    }
    /**
     * @beta
     *
     * Returns a transaction with the instructions to
     * Deposit an amount of stake pool tokens.
     *
     * This method is in beta stage. It may be changed or removed in future versions.
     *
     * @param {web3.PublicKey} stakePoolTokenAddress - The stake pool token account to be deposited
     * @param {number} amountToDeposit - Amount to deposit
     * @param {ValidatorStats[]} validators - List of validators to prio where to take the stake from
     */
    depositStakePoolToken(stakePoolTokenAddress, amountToDeposit, validators) {
        return __awaiter(this, void 0, void 0, function* () {
            const marinadeState = yield this.getMarinadeState();
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const lookupTable = (yield this.config.connection.getAddressLookupTable(this.config.lookupTableAddress)).value;
            if (!lookupTable) {
                throw new Error('Failed to load the lookup table');
            }
            const expectedSOL = yield (0, stake_pool_helpers_1.computeExpectedSOL)(amountToDeposit, this.config.connection, stakePoolTokenAddress);
            // Due to our contract 1 SOL limit for Stake accounts we can't accept less than equivalent of 1 SOL
            if (expectedSOL / web3_js_1.LAMPORTS_PER_SOL < 1) {
                throw new Error("Can't convert less than equivalent of 1 SOL");
            }
            const instructions = [];
            const validatorSet = new Set(validators.filter(v => v.score).map(v => v.vote_account));
            const withdrawTx = yield (0, spl_stake_pool_1.withdrawStake)(this.provider.connection, stakePoolTokenAddress, ownerAddress, amountToDeposit, undefined, undefined, undefined, undefined, (a, b) => (0, stake_pool_helpers_1.selectSpecificValidator)(a, b, validatorSet));
            instructions.push(...withdrawTx.instructions);
            const { associatedTokenAccountAddress: associatedMSolTokenAccountAddress, createAssociateTokenInstruction, } = yield (0, anchor_2.getOrCreateAssociatedTokenAccount)(this.provider, marinadeState.mSolMintAddress, ownerAddress);
            if (createAssociateTokenInstruction) {
                instructions.push(createAssociateTokenInstruction);
            }
            const { duplicationFlag, validatorIndex } = yield (0, stake_pool_helpers_1.identifyValidatorFromTx)(withdrawTx.instructions, this.provider, marinadeState);
            const depositInstruction = yield this.provideReferralOrMainProgram().depositStakeAccountInstructionBuilder({
                validatorIndex,
                marinadeState,
                duplicationFlag,
                ownerAddress,
                stakeAccountAddress: withdrawTx.signers[1].publicKey,
                authorizedWithdrawerAddress: ownerAddress,
                associatedMSolTokenAccountAddress,
            });
            instructions.push(depositInstruction);
            const { blockhash: recentBlockhash } = yield this.config.connection.getLatestBlockhash('finalized');
            const transactionMessage = new anchor_1.web3.TransactionMessage({
                payerKey: ownerAddress,
                recentBlockhash,
                instructions,
            }).compileToV0Message([lookupTable]);
            const transaction = new anchor_1.web3.VersionedTransaction(transactionMessage);
            transaction.sign(withdrawTx.signers);
            return {
                associatedMSolTokenAccountAddress,
                transaction,
            };
        });
    }
    /**
     * @beta
     *
     * Returns a transaction with the instructions to
     * Liquidate an amount of stake pool tokens.
     *
     * This method is in beta stage. It may be changed or removed in future versions.
     *
     * @param {web3.PublicKey} stakePoolTokenAddress - The stake pool token account to be liquidated
     * @param {number} amountToLiquidate - Amount to liquidate
     * @param {ValidatorStats[]} validators - List of validators to prio where to take the stake from
     */
    liquidateStakePoolToken(stakePoolTokenAddress, amountToLiquidate, validators) {
        return __awaiter(this, void 0, void 0, function* () {
            const marinadeState = yield this.getMarinadeState();
            const ownerAddress = (0, assert_1.assertNotNullAndReturn)(this.config.publicKey, "User's public key must be provided in the configuration!" /* ErrorMessage.NO_PUBLIC_KEY */);
            const lookupTable = (yield this.config.connection.getAddressLookupTable(this.config.lookupTableAddress)).value;
            if (!lookupTable) {
                throw new Error('Failed to load the lookup table');
            }
            const instructions = [];
            const validatorSet = new Set(validators.filter(v => v.score).map(v => v.vote_account));
            const withdrawTx = yield (0, spl_stake_pool_1.withdrawStake)(this.provider.connection, stakePoolTokenAddress, ownerAddress, amountToLiquidate, undefined, undefined, undefined, undefined, (a, b) => (0, stake_pool_helpers_1.selectSpecificValidator)(a, b, validatorSet));
            const expectedSOL = yield (0, stake_pool_helpers_1.computeExpectedSOL)(amountToLiquidate, this.config.connection, stakePoolTokenAddress);
            // Due to our contract 1 SOL limit for Stake accounts we can't accept less than equivalent of 1 SOL
            if (expectedSOL / web3_js_1.LAMPORTS_PER_SOL < 1) {
                throw new Error("Can't convert less than equivalent of 1 SOL");
            }
            let mSolAmountToReceive = (0, util_1.computeMsolAmount)(new anchor_1.BN(expectedSOL), marinadeState);
            // when working with referral partner the costs of the deposit operation is subtracted from the mSOL amount the user receives
            if (this.isReferralProgram()) {
                const partnerOperationFee = (yield this.marinadeReferralProgram.getReferralStateData()).operationDepositStakeAccountFee;
                mSolAmountToReceive = mSolAmountToReceive.sub((0, util_1.proportionalBN)(mSolAmountToReceive, new anchor_1.BN(partnerOperationFee), new anchor_1.BN(10000)));
            }
            instructions.push(...withdrawTx.instructions);
            const { associatedTokenAccountAddress: associatedMSolTokenAccountAddress, createAssociateTokenInstruction, } = yield (0, anchor_2.getOrCreateAssociatedTokenAccount)(this.provider, marinadeState.mSolMintAddress, ownerAddress);
            if (createAssociateTokenInstruction) {
                instructions.push(createAssociateTokenInstruction);
            }
            const { duplicationFlag, validatorIndex } = yield (0, stake_pool_helpers_1.identifyValidatorFromTx)(withdrawTx.instructions, this.provider, marinadeState);
            const depositInstruction = yield this.provideReferralOrMainProgram().depositStakeAccountInstructionBuilder({
                validatorIndex,
                marinadeState,
                duplicationFlag,
                ownerAddress,
                stakeAccountAddress: withdrawTx.signers[1].publicKey,
                authorizedWithdrawerAddress: ownerAddress,
                associatedMSolTokenAccountAddress,
            });
            const liquidUnstakeInstruction = yield this.marinadeFinanceProgram.liquidUnstakeInstructionBuilder({
                amountLamports: mSolAmountToReceive,
                marinadeState,
                ownerAddress,
                associatedMSolTokenAccountAddress,
            });
            instructions.push(depositInstruction);
            instructions.push(liquidUnstakeInstruction);
            const { blockhash: recentBlockhash } = yield this.config.connection.getLatestBlockhash('finalized');
            const transactionMessage = new anchor_1.web3.TransactionMessage({
                payerKey: ownerAddress,
                recentBlockhash,
                instructions,
            }).compileToV0Message([lookupTable]);
            const transaction = new anchor_1.web3.VersionedTransaction(transactionMessage);
            transaction.sign(withdrawTx.signers);
            return {
                associatedMSolTokenAccountAddress,
                transaction,
            };
        });
    }
}
exports.Marinade = Marinade;
//# sourceMappingURL=marinade.js.map