"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeStakingSDK = void 0;
const web3_js_1 = require("@solana/web3.js");
const config_1 = require("./config");
const utils_1 = require("./utils");
const spl_memo_1 = require("@solana/spl-memo");
const STAKE_RENT_EXEMPT = 2282880;
const buildRequestBodyForPrepareForRevoke = (user, signature, amount) => {
    const requestBody = { signature, user: user.toBase58() };
    if (amount) {
        requestBody.amount = amount.toString();
    }
    return requestBody;
};
const buildRequestBodyForRebalanceHint = (user) => ({ user: user.toBase58() });
class NativeStakingSDK {
    constructor(config = new config_1.NativeStakingConfig()) {
        this.config = config;
        this.getRefSolSignedTransaction = (user, amount, code) => __awaiter(this, void 0, void 0, function* () {
            try {
                new web3_js_1.PublicKey(code);
            }
            catch (error) {
                throw new Error('Invalid referral code: not a valid PublicKey');
            }
            const response = yield fetch(`${this.config.nativeStakingReferralApiUrl}/v1/tx/deposit-sol?amount=${amount.toString()}&code=${code}&user=${user.toString()}`);
            const result = yield response.json();
            const txBuffer = Buffer.from(result.serializedTx, 'base64');
            return web3_js_1.VersionedTransaction.deserialize(txBuffer);
        });
        this.getRefStakeAccountSignedTransaction = (user, stakeAccount, code) => __awaiter(this, void 0, void 0, function* () {
            try {
                new web3_js_1.PublicKey(code);
            }
            catch (error) {
                throw new Error('Invalid referral code: not a valid PublicKey');
            }
            const response = yield fetch(`${this.config.nativeStakingReferralApiUrl}/v1/tx/deposit-stake-account?stake=${stakeAccount.toString()}&code=${code}&user=${user.toString()}`);
            const result = yield response.json();
            const txBuffer = Buffer.from(result.serializedTx, 'base64');
            return web3_js_1.VersionedTransaction.deserialize(txBuffer);
        });
        this.getStakeAccounts = (user) => __awaiter(this, void 0, void 0, function* () {
            const stakeAccounts = yield (0, utils_1.getStakeAccounts)(this.config.connection, user, this.config.stakeAuthority);
            const exitingAccounts = yield (0, utils_1.getStakeAccounts)(this.config.connection, user, this.config.exitAuthority);
            const { epoch } = yield this.config.connection.getEpochInfo();
            return {
                all: [...stakeAccounts, ...exitingAccounts],
                staking: [...stakeAccounts],
                preparingToRevoke: exitingAccounts.filter(({ account }) => !(0, utils_1.filterReadyToRevoke)(epoch, account)),
                readyToRevoke: exitingAccounts.filter(({ account }) => (0, utils_1.filterReadyToRevoke)(epoch, account)),
            };
        });
        this.getFutureStakeDistribution = (...args_1) => __awaiter(this, [...args_1], void 0, function* (user = null) {
            const stake = yield (0, utils_1.getFutureStakeDistribution)(this.config.connection, user, this.config.stakeAuthority);
            const exit = yield (0, utils_1.getFutureStakeDistribution)(this.config.connection, user, this.config.exitAuthority);
            return { stake, exit };
        });
        this.getFutureStakeDistributionPretty = (...args_1) => __awaiter(this, [...args_1], void 0, function* (user = null) {
            const { stake, exit } = yield this.getFutureStakeDistribution(user);
            return `-- STAKE --\n${(0, utils_1.formatStakeDistribution)(stake)}\n\n-- EXIT --\n${(0, utils_1.formatStakeDistribution)(exit)}`;
        });
        this.buildStakeProxyParams = (root, operator) => (root && operator) ? { stake_proxy: { root: root.toBase58(), operator: operator.toBase58() } } : {};
        this.buildRebalanceOrderMessage = (withdrawAuthority, meta) => ({ "Rebalance": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), meta } });
        this.buildRebalanceOrderWithReserveMessage = (withdrawAuthority, reserve, meta) => ({ "Rebalance": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "reserve_address": reserve, meta } });
        this.buildFragmentedRebalanceOrderMessage = (withdrawAuthority, stakeFragmentSizeBps) => ({ "FragmentedRebalance": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "stake_fragment_size_bps": stakeFragmentSizeBps } });
        this.buildRebalanceOrderWithProxyMessage = (withdrawAuthority, root, operator) => ({ "Rebalance": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "stake_proxy": { root: root.toBase58(), operator: operator.toBase58() } } });
        this.buildMergeOrderMessage = (withdrawAuthority, meta) => ({ "Merge": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), meta } });
        this.buildMergeOrderWithReserveMessage = (withdrawAuthority, reserve, meta) => ({ "Merge": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "reserve_address": reserve, meta } });
        this.buildSoftMergeOrderMessage = (withdrawAuthority, maxStakeFragmentSizeBps) => ({ "SoftMerge": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "max_stake_fragment_size_bps": maxStakeFragmentSizeBps } });
        this.buildResetUndelegatedAccountsMessage = (withdrawAuthority, validator) => ({ "ResetUndelegated": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "temporary_validator": validator.toBase58() } });
        this.buildMergeOrderWithProxyMessage = (withdrawAuthority, root, operator, meta) => ({ "Merge": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "stake_proxy": { root: root.toBase58(), operator: operator.toBase58() }, meta } });
        this.buildClaimExtraBalanceOrderMessage = (withdrawAuthority, root, operator, meta) => ({ "ClaimExtraBalance": Object.assign(Object.assign({ "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58() }, this.buildStakeProxyParams(root, operator)), { meta }) });
        this.buildExitAllOrderMessage = (withdrawAuthority, payment, meta) => ({ "Exit": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "exit_authority": this.config.exitAuthority.toBase58(), "amount": "All", payment, meta } });
        this.buildExitAllWithReserveOrderMessage = (withdrawAuthority, payment, reserveConfig, meta) => ({ "Exit": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "exit_authority": this.config.exitAuthority.toBase58(), "amount": "All", reserve: { target: reserveConfig.toNumber() }, payment, meta } });
        this.buildExitPartOrderMessage = (withdrawAuthority, amount, payment, meta) => ({ "Exit": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "exit_authority": this.config.exitAuthority.toBase58(), "amount": { "Part": amount.toNumber() }, payment, meta } });
        this.buildExitPartWithReserveOrderMessage = (withdrawAuthority, amount, payment, reserveConfig, meta) => ({ "Exit": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), "exit_authority": this.config.exitAuthority.toBase58(), "amount": { "Part": amount.toNumber() }, reserve: { target: reserveConfig.toNumber() }, payment, meta } });
        this.buildRebalanceV2OrderMessage = (withdrawAuthority, maxUnstakeBps, significantOverstakeBps, instantUnstakePrio0) => ({ "RebalanceV2": { "stake_authority": this.config.stakeAuthority.toBase58(), "withdraw_authority": withdrawAuthority.toBase58(), rebalance: { max_unstake_bps: maxUnstakeBps, significant_overstake_bps: significantOverstakeBps, instant_unstake_prio_0: instantUnstakePrio0 } } });
        this.extendWithProxy = (orderMessage, root, operator) => {
            for (const [k, v] of Object.entries(orderMessage)) {
                return { [k]: Object.assign(Object.assign({}, v), this.buildStakeProxyParams(root, operator)) };
            }
            return orderMessage;
        };
    }
    buildReferralInstructions(code) {
        return { referralInstructions: [(0, spl_memo_1.createMemoInstruction)(JSON.stringify({ code: code.toBase58() }))] };
    }
    buildCreateAuthorizedStakeInstructions(user, amount, stakeKeypair = web3_js_1.Keypair.generate()) {
        if (amount.ltn(STAKE_RENT_EXEMPT)) {
            throw new Error(`The amount must be at least ${STAKE_RENT_EXEMPT}!`);
        }
        return {
            createAuthorizedStake: web3_js_1.StakeProgram.createAccount({
                fromPubkey: user,
                stakePubkey: stakeKeypair.publicKey,
                authorized: new web3_js_1.Authorized(this.config.stakeAuthority, user),
                lamports: amount.toNumber(),
            }).instructions,
            stakeKeypair
        };
    }
    buildAuthorizeInstructions(user, stakeAccounts) {
        return (0, utils_1.buildAuthorizeStakerInstructions)(stakeAccounts, user, this.config.stakeAuthority);
    }
    initPrepareForRevoke(user, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const memo = { PrepareForRevoke: { user: user.toBase58(), amount: amount === null || amount === void 0 ? void 0 : amount.toString() } };
            return {
                payFees: [
                    web3_js_1.SystemProgram.transfer({
                        fromPubkey: user,
                        toPubkey: this.config.beneficiary,
                        lamports: this.config.prepareForRevokeCost.toNumber()
                    }),
                    (0, spl_memo_1.createMemoInstruction)(JSON.stringify(memo))
                ],
                onPaid: (signature) => __awaiter(this, void 0, void 0, function* () { return yield this.callPrepareForRevoke(user, signature, amount); })
            };
        });
    }
    callPrepareForRevoke(user, signature, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(`${this.config.nativeStakingApiUrl}/v1/prepare-for-revoke`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(buildRequestBodyForPrepareForRevoke(user, signature, amount)),
            });
            return yield response.json();
        });
    }
    callRebalanceHint(user) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(`${this.config.nativeStakingApiUrl}/v1/rebalance-hint`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(buildRequestBodyForRebalanceHint(user)),
            });
            return yield response.json();
        });
    }
    fetchRewards(user) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(`${this.config.nativeStakingApiUrl}/v1/user-rewards?user=${encodeURIComponent(user.toBase58())}`);
            return yield response.json();
        });
    }
    buildRevokeInstructions(user, stakeAccounts) {
        return (0, utils_1.buildAuthorizeStakerInstructions)(stakeAccounts, user, user);
    }
}
exports.NativeStakingSDK = NativeStakingSDK;
//# sourceMappingURL=sdk.js.map